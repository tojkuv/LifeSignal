import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import Foundation

// MARK: - LifeSignal Architecture Macros

/// Macro that enforces client architectural constraints and generates development utilities
public struct LifeSignalClientMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        // Validate that this is applied to a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw MacroError.invalidTarget("@LifeSignalClient can only be applied to structs")
        }
        
        let structName = structDecl.name.text
        
        // Validate naming convention
        guard structName.hasSuffix("Client") else {
            throw MacroError.namingViolation("Client \(structName) should follow naming convention: *Client")
        }
        
        // Generate validation and helper methods
        let generatedMethods = try generateClientMethods(for: structName, context: context)
        
        return generatedMethods
    }
    
    private static func generateClientMethods(for clientName: String, context: some MacroExpansionContext) throws -> [DeclSyntax] {
        let stateTypeName = clientName.replacingOccurrences(of: "Client", with: "State")
        
        // Generate an extension with all the static methods
        let extensionDecl: DeclSyntax = """
        // Generated by @LifeSignalClient macro
        extension \(raw: clientName) {
            public static func validateArchitecture() -> [String] {
                return []  // Simplified for now - macro validation happens at compile time
            }
            
            public static func registerDependencies() {
                // Generated dependency registration - would be called during app startup
            }
            
            public static func auditStateAccess() {
                // Generated state access audit - would be called during development
            }
        }
        """
        
        return [extensionDecl]
    }
}

/// Macro that enforces feature architectural constraints and generates development utilities
public struct LifeSignalFeatureMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        // Validate that this is applied to a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw MacroError.invalidTarget("@LifeSignalFeature can only be applied to structs")
        }
        
        let structName = structDecl.name.text
        
        // Validate naming convention
        guard structName.hasSuffix("Feature") else {
            throw MacroError.namingViolation("Feature \(structName) should follow naming convention: *Feature")
        }
        
        // Generate validation and helper methods
        let generatedMethods = try generateFeatureMethods(for: structName, in: structDecl, context: context)
        
        return generatedMethods
    }
    
    private static func generateFeatureMethods(for featureName: String, in structDecl: StructDeclSyntax, context: some MacroExpansionContext) throws -> [DeclSyntax] {
        // Generate an extension with all the static methods
        let extensionDecl: DeclSyntax = """
        // Generated by @LifeSignalFeature macro
        extension \(raw: featureName) {
            public static func validateArchitecture() -> [String] {
                return []  // Simplified for now - macro validation happens at compile time
            }
            
            public static func generateStateHelpers() {
                // Generated state access helpers for safe @Shared state reading
            }
            
            public static func auditClientInteractions() {
                // Generated client interaction audit logging
            }
        }
        """
        
        return [extensionDecl]
    }
}

/// Macro that enforces view architectural constraints and generates development utilities
public struct LifeSignalViewMacro: PeerMacro {
    public static func expansion(
        of node: AttributeSyntax,
        providingPeersOf declaration: some DeclSyntaxProtocol,
        in context: some MacroExpansionContext
    ) throws -> [DeclSyntax] {
        
        // Validate that this is applied to a struct
        guard let structDecl = declaration.as(StructDeclSyntax.self) else {
            throw MacroError.invalidTarget("@LifeSignalView can only be applied to structs")
        }
        
        let structName = structDecl.name.text
        
        // Validate naming convention
        guard structName.hasSuffix("View") else {
            throw MacroError.namingViolation("View \(structName) should follow naming convention: *View")
        }
        
        // Validate ViewContext constraints
        try validateViewConstraints(in: structDecl)
        
        // Generate validation and helper methods
        let generatedMethods = try generateViewMethods(for: structName, context: context)
        
        return generatedMethods
    }
    
    private static func validateViewConstraints(in structDecl: StructDeclSyntax) throws {
        // Check for illegal @Dependency usage
        let memberList = structDecl.memberBlock.members
        
        for member in memberList {
            if let variableDecl = member.decl.as(VariableDeclSyntax.self) {
                for attribute in variableDecl.attributes {
                    if let attr = attribute.as(AttributeSyntax.self),
                       attr.attributeName.as(IdentifierTypeSyntax.self)?.name.text == "Dependency" {
                        throw MacroError.viewConstraintViolation("View \(structDecl.name.text) uses illegal @Dependency - should access data through store only")
                    }
                    
                    if let attr = attribute.as(AttributeSyntax.self),
                       attr.attributeName.as(IdentifierTypeSyntax.self)?.name.text == "Shared" {
                        throw MacroError.viewConstraintViolation("View \(structDecl.name.text) uses illegal @Shared - should access data through store only")
                    }
                }
            }
        }
    }
    
    private static func generateViewMethods(for viewName: String, context: some MacroExpansionContext) throws -> [DeclSyntax] {
        // Generate an extension with all the static methods
        let extensionDecl: DeclSyntax = """
        // Generated by @LifeSignalView macro
        extension \(raw: viewName) {
            public static func validateArchitecture() -> [String] {
                return []  // Simplified for now - macro validation happens at compile time
            }
            
            public static func generateViewHelpers() {
                // Generated view binding helpers for safe store access
            }
            
            public static func auditActionDispatches() {
                // Generated action dispatch audit logging
            }
        }
        """
        
        return [extensionDecl]
    }
}

// MARK: - Macro Errors

enum MacroError: Error, CustomStringConvertible {
    case invalidTarget(String)
    case namingViolation(String)
    case viewConstraintViolation(String)
    case featureConstraintViolation(String)
    case clientConstraintViolation(String)
    
    var description: String {
        switch self {
        case .invalidTarget(let message):
            return "Invalid macro target: \(message)"
        case .namingViolation(let message):
            return "Naming convention violation: \(message)"
        case .viewConstraintViolation(let message):
            return "ViewContext constraint violation: \(message)"
        case .featureConstraintViolation(let message):
            return "FeatureContext constraint violation: \(message)"
        case .clientConstraintViolation(let message):
            return "ClientContext constraint violation: \(message)"
        }
    }
}

// MARK: - Compiler Plugin

@main
struct LifeSignalMacrosPlugin: CompilerPlugin {
    let providingMacros: [Macro.Type] = [
        LifeSignalClientMacro.self,
        LifeSignalFeatureMacro.self,
        LifeSignalViewMacro.self,
    ]
}